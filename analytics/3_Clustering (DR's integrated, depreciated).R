#Author: Doipayan Roy
#Institution: Purdue University
#Project: EdX data pipeline for clustering analytics
#Last modified: 9th May, 2017
#Version: 5

#This program uses the preprocessed_data.csv file generated by Preprocessing.R
#Preprocessing.R has to be run before this program is executed
#preprocessed_data.csv is read as the dataFrame object named data

##########Reading preprocessed file, converting to dataframe object, eliminating irrelevant columns############################################################################################################################

var<-readline(prompt="For clustering on a specific gender: enter 'm' to cluster only male learners, 'f' to cluster only female learners. To cluster all learners, enter anything else: ");
var<-as.character(var);
if(var=='m')
{
  data<-read.csv("preprocessed_data_males.csv",header=T)
} else if(var=='f')
{
  data<-read.csv("preprocessed_data_females.csv",header=T)
} else
{
  data<-read.csv("preprocessed_data.csv",header=T)
}
#Converting to dataFrame object
data<-as.data.frame(data)
#Retaining only relevant columns
data<-data[names(data) %in% c("temp_student_id","module_number","time")]
#Ordering dataframe by student_id column
data<-data[order(data$temp_student_id,decreasing=F),]

###############################################################################################################################################################################################################################

##########Calculating number of unique module accesses for each student and saving to file#####################################################################################################################################

print("Calculating number of access events for each learner...",quote=FALSE)
#access_list contains the number of unique module accesses for each learner
access_list=c()
for(i in 1:length(unique(data$temp_student_id)))
{
  temp=subset(data,data$temp_student_id==i)
  access_list=c(access_list,nrow(temp))
}
print("Done! Saving to file...",quote=FALSE)
#data_final contains the columns required for clustering
data_final=data.frame(1:length(unique(data$temp_student_id)),access_list)
#Renaming columns and writing to file
names(data_final)<-c("temp_student_id","number_accesses")
if(var=='m')
{
  write.csv(data_final,"access_data_males.csv")
} else if(var=='f')
{
  write.csv(data_final,"access_data_females.csv")
} else
{
  write.csv(data_final,"access_data.csv")
}

#Clearing all variables except var
rm(list=setdiff(ls(),'var'))

###############################################################################################################################################################################################################################

##########Choose clustering technique##########################################################################################################################################################################################

n<-readline(prompt="Enter 1 for K-means clustering, 2 for Fuzzy means clustering: ");
n<-as.integer(n);

###############################################################################################################################################################################################################################

##########If choice is K means#################################################################################################################################################################################################

if(n==1)
{
  #Read access_data.csv file and delete irrelevant columns
  if(var=='m')
  {
    data<-read.csv("access_data_males.csv",header=T)
  } else if(var=='f')
  {
    data<-read.csv("access_data_females.csv",header=T)
  } else
  {
    data<-read.csv("access_data.csv",header=T)
  }
  data<-as.data.frame(data)
  data<-data[names(data) %in% c("temp_student_id","number_accesses")]
  
  #Generate elbow plot from access data using K=1 to K=10 (K = number of clusters)
  print("Generating elbow plot...",quote=FALSE)
  #elbow_plot_values is a list of betweenClusterSumofSquares/totalSumofSquares for K = 1 to 10
  elbow_plot_values=c()
  for(k in 1:10)
  {
    K_m=kmeans(data$number_accesses,centers=k,iter.max=50,algorithm="Lloyd")
    elbow_plot_values=c(elbow_plot_values,K_m$betweenss/K_m$totss)
  }
  #Plot elbow plot
  x=1:10
  setEPS()
  if(var=='m')
  {
    postscript("elbow_plot_males.eps")
    plot(x,elbow_plot_values,col="blue",xlim=c(0,10),ylim=c(0,1.2),xlab="Number of clusters",ylab="Between cluster sum of squares / Total sum of squares",main="Elbow plot for male learners",type="l")
  } else if(var=='f')
  {
    postscript("elbow_plot_females.eps")
    plot(x,elbow_plot_values,col="blue",xlim=c(0,10),ylim=c(0,1.2),xlab="Number of clusters",ylab="Between cluster sum of squares / Total sum of squares",main="Elbow plot for female learners",type="l")
  } else
  {
    postscript("elbow_plot_all_users.eps")
    plot(x,elbow_plot_values,col="blue",xlim=c(0,10),ylim=c(0,1.2),xlab="Number of clusters",ylab="Between cluster sum of squares / Total sum of squares",main="Elbow plot for all learners",type="l")
  }
  dev.off()
  print("Done!",quote=FALSE)
  
  #Generate gap plot from access data for K = 1 to 10 (K = number of clusters)
  print("Generating gap plot...",quote=FALSE)
  gap_statistic=cluster::clusGap(as.matrix(data$number_accesses),K.max=10,FUN=kmeans,verbose=FALSE)
  gap_values=(as.data.frame(gap_statistic$Tab))$gap
  #Plot gap plot
  x=1:10
  setEPS()
  if(var=='m')
  {
    postscript("gap_plot_males.eps")
    plot(x,gap_values,col="black",xlim=c(0,10),ylim=c(0,0.5),xlab="Number of clusters",ylab="Gap",main="Gap plot for male learners",type="l")
  } else if(var=='f')
  {
    postscript("gap_plot_females.eps")
    plot(x,gap_values,col="black",xlim=c(0,10),ylim=c(0,0.5),xlab="Number of clusters",ylab="Gap",main="Gap plot for female learners",type="l")
  } else
  {
    postscript("gap_plot_all_users.eps")
    plot(x,gap_values,col="black",xlim=c(0,10),ylim=c(0,0.5),xlab="Number of clusters",ylab="Gap",main="Gap plot for all learners",type="l")
  }
  dev.off()
  print("Done!",quote=FALSE)
  
  #Make recommendation for number of clusters based on elbow plot (increase from k to k+1 clusters less than 2%)
  for(i in 2:10)
  {
    #Calculate percentage increase in explained variance from k to k+1 clusters
    percent_inc=(elbow_plot_values[i]-elbow_plot_values[i-1])/elbow_plot_values[i-1]
    if(percent_inc<0.02)
    {
      print(paste("Recommendation for number of clusters using elbow plot:",i-1),quote=FALSE)
      break
    }
  }
  
  #Make recommendation for number of clusters based on gap statistics (first peak in plot)
  for(i in 2:9)
  {
    if(gap_values[i-1]<gap_values[i] & gap_values[i+1]<gap_values[i])
    {
      print(paste("Recommendation for number of clusters using gap statistics:",i),quote=FALSE)
      break
    }
  }
  #Clearing all variables except var
  rm(list=setdiff(ls(),'var'))
  
  #User input for number of clusters
  K<-readline("Enter the desired number of clusters (maximum 10): ");
  K<-as.integer(K);
  
  #Reading preprocessed_data.csv and access_data.csv and converting to dataFrame object
  if(var=='m')
  {
    data_preprocessed<-read.csv("preprocessed_data_males.csv",header=T)
    data_access<-read.csv("access_data_males.csv",header=T)
  } else if(var=='f')
  {
    data_preprocessed<-read.csv("preprocessed_data_females.csv",header=T)
    data_access<-read.csv("access_data_females.csv",header=T)
  } else
  {
    data_preprocessed<-read.csv("preprocessed_data.csv",header=T)
    data_access<-read.csv("access_data.csv",header=T)
  }
  data_preprocessed<-as.data.frame(data_preprocessed)
  data_access<-as.data.frame(data_access)
  #Retaining only relevant columns in data_preprocessed
  data_preprocessed<-data_preprocessed[names(data_preprocessed) %in% c("temp_student_id","module_number")]
  #Retaining only relevant columns in data_access
  data_access<-data_access[names(data_access) %in% c("temp_student_id","number_accesses")]
  #Ordering data_access in increasing order of temporary student it (integer id created for each student in preprocessing)
  data_access=data_access[order(data_access$temp_student_id,decreasing=F),]
  #Performing K-means clustering on access data using user's choice of K
  K_m<-kmeans(data_access$number_accesses,centers=K,iter.max=100,algorithm="Lloyd")
  cluster_id=K_m$cluster
  #Binding cluster_id of each student to data_access
  data_access=cbind(data_access,cluster_id)
  #Ordering data_access in increasing order of number of unique accesses of students
  data_access<-data_access[order(data_access$number_accesses,decreasing=F),]
  
  #Ordering clusters in decreasing order of accesses, heaviest user cluster comes first and so on
  #mean_accesses is a list of the average number of accesses per user in each cluster
  #cluster_order contains the cluster_id's ordered in increasing order of access activity
  counter=1
  mean_accesses=c()
  cluster_order=c()
  for(i in 1:K)
  {
    temp=subset(data_access,data_access$cluster_id==i)
    mean_accesses=c(mean_accesses,mean(temp$number_accesses))
  }
  mean_accesses_sorted=sort(mean_accesses,decreasing=F)
  for(i in 1:K)
  {
    cluster_order=c(cluster_order,which(mean_accesses==mean_accesses_sorted[i]))
  }
  
  #Plotting clusters
  print("Plotting clusters...",quote=FALSE)
  x=1:length(unique(data_preprocessed$module_number))
  setEPS()
  if(var=='m')
  {
    postscript("Cluster_kmeans_males.eps")
    plot(1,pch=".",col="white",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab="Module number",ylab="Users",main="Male users clustered by courseware access using K-means clustering")
  }else if(var=='f')
  {
    postscript("Cluster_kmeans_females.eps")
    plot(1,pch=".",col="white",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab="Module number",ylab="Users",main="Female users clustered by courseware access using K-means clustering")
  }else
  {
    postscript("Cluster_kmeans_all_users.eps")
    plot(1,pch=".",col="white",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab="Module number",ylab="Users",main="All users clustered by courseware access using K-means clustering")
  }
  par(new=T)
  for(k in cluster_order)
  {
    #Subset of students belonging to cluster_id=k
    temp=subset(data_access,data_access$cluster_id==k)
    #for loop iterating over every clickstream event in subset obtained above
    for(j in 1:nrow(temp))
    {
      stud_id=temp$temp_student_id[j]
      temp2=subset(data_preprocessed,data_preprocessed$temp_student_id==stud_id)
      access_list=rep(NA,length(unique(data_preprocessed$module_number)))
      for(i in 1:length(access_list))
      {
        if(i %in% temp2$module_number)
        {
          access_list[i]=i
        }
      }
      #plot each cluster (from 1 to a maximum of 10) using a different color
      if(k==1)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="red",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==2)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="blue",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==3)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="black",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==4)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="green",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==5)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="yellow",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==6)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="pink",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==7)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="orange",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==8)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="brown",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==9)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="darkgrey",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==10)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="cyan",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
    }
  }
  dev.off()
  print("Done! The results of hypothesis testing on access events between clusters: ",quote=FALSE)
  #Kruskal-Wallis test to show that clustering is statistically significant
  Krus_Wal=kruskal.test(data_access$number_accesses~data_access$cluster_id,data=data_access)
  print(paste("P-value for Kruskal-Wallis test for access events between clusters is ",Krus_Wal$p.value,"..."),quote=FALSE)
  #Mann-Whitney-Wilcoxon test to test if clusters are pair-wise distinct 
  counter=0
  for(i in 1:(K-1))
  {
    for(j in (i+1):K)
    {
      data_subset=subset(data_access,data_access$cluster_id==i | data_access$cluster_id==j)
      Mann_Whit=wilcox.test(data_subset$number_accesses~data_subset$cluster_id,data=data_subset)
      if(Mann_Whit$p.value>0.01)
      {
        print(paste("Clusters ",i," and ",j," are not statistically significant (using p-value threshold of 0.01)..."),quote=F)
      }
      else
      {
        counter=counter+1
      }
    }
  }
  #(K choose 2) pairings, if counter = (K choose 2), all clusters are pairwise significant
  if(counter==(K*(K-1)/2))
  {
    print("All clusters are pairwise distinct, i.e. has p-value less than 0.01...",quote=F)
  }
  
  #Clear all variables except var
  rm(list=ls())
  
} else if(n==2)
{
  
##########If choice is C means#################################################################################################################################################################################################
  
  #Read access_data.csv file and delete irrelevant columns
  if(var=='m')
  {
    data<-read.csv("access_data_males.csv",header=T)
  } else if(var=='f')
  {
    data<-read.csv("access_data_females.csv",header=T)
  } else
  {
    data<-read.csv("access_data.csv",header=T)
  }
  data<-as.data.frame(data)
  data<-data[names(data) %in% c("temp_student_id","number_accesses")]
  
  #Generate gap plot from access data for K = 1 to 10 (K = number of clusters)
  print("Generating gap plot...",quote=FALSE)
  gap_statistic=cluster::clusGap(as.matrix(data$number_accesses),K.max=10,FUN=kmeans,verbose=FALSE)
  gap_values=(as.data.frame(gap_statistic$Tab))$gap
  #Plot gap plot
  x=1:10
  setEPS()
  if(var=='m')
  {
    postscript("gap_plot_males.eps")
    plot(x,gap_values,col="black",xlim=c(0,10),ylim=c(0,0.5),xlab="Number of clusters",ylab="Gap",main="Gap plot for male learners",type="l")
  } else if(var=='f')
  {
    postscript("gap_plot_females.eps")
    plot(x,gap_values,col="black",xlim=c(0,10),ylim=c(0,0.5),xlab="Number of clusters",ylab="Gap",main="Gap plot for female learners",type="l")
  } else
  {
    postscript("gap_plot_all_users.eps")
    plot(x,gap_values,col="black",xlim=c(0,10),ylim=c(0,0.5),xlab="Number of clusters",ylab="Gap",main="Gap plot for all learners",type="l")
  }
  dev.off()
  print("Done!",quote=FALSE)
  
  #Make recommendation for number of clusters based on gap statistics (first peak in plot)
  for(i in 2:9)
  {
    if(gap_values[i-1]<gap_values[i] & gap_values[i+1]<gap_values[i])
    {
      print(paste("Recommendation for number of clusters using gap statistics:",i),quote=FALSE)
      break
    }
  }
  
  #Clearing all variables except var
  rm(list=setdiff(ls(),'var'))
  
  #User input for number of clusters
  K<-readline("Enter the desired number of clusters (maximum 10): ");
  K<-as.integer(K);
  
  #Reading preprocessed_data.csv and access_data.csv and converting to dataFrame object
  if(var=='m')
  {
    data_preprocessed<-read.csv("preprocessed_data_males.csv",header=T)
    data_access<-read.csv("access_data_males.csv",header=T)
  } else if(var=='f')
  {
    data_preprocessed<-read.csv("preprocessed_data_females.csv",header=T)
    data_access<-read.csv("access_data_females.csv",header=T)
  } else
  {
    data_preprocessed<-read.csv("preprocessed_data.csv",header=T)
    data_access<-read.csv("access_data.csv",header=T)
  }
  data_preprocessed<-as.data.frame(data_preprocessed)
  data_access<-as.data.frame(data_access)
  #Retaining only relevant columns in data_preprocessed
  data_preprocessed<-data_preprocessed[names(data_preprocessed) %in% c("temp_student_id","module_number")]
  #Retaining only relevant columns in data_access
  data_access<-data_access[names(data_access) %in% c("temp_student_id","number_accesses")]
  #Ordering data_access in increasing order of temporary student it (integer id created for each student in preprocessing)
  data_access=data_access[order(data_access$temp_student_id,decreasing=F),]
  #Performing C-means clustering on access data using user's choice of K
  C_m<-e1071::cmeans(as.matrix(data_access$number_accesses),centers=K)
  cluster_id=C_m$cluster
  #Binding cluster_id of each student to data_access
  data_access=cbind(data_access,cluster_id)
  #Ordering data_access in increasing order of number of unique accesses of students
  data_access<-data_access[order(data_access$number_accesses,decreasing=F),]
  
  #Ordering clusters in decreasing order of accesses, heaviest user cluster comes first and so on
  #mean_accesses is a list of the average number of accesses per user in each cluster
  #cluster_order contains the cluster_id's ordered in increasing order of access activity
  counter=1
  mean_accesses=c()
  cluster_order=c()
  for(i in 1:K)
  {
    temp=subset(data_access,data_access$cluster_id==i)
    mean_accesses=c(mean_accesses,mean(temp$number_accesses))
  }
  mean_accesses_sorted=sort(mean_accesses,decreasing=F)
  for(i in 1:K)
  {
    cluster_order=c(cluster_order,which(mean_accesses==mean_accesses_sorted[i]))
  }
  
  #Plotting clusters
  print("Plotting clusters...",quote=FALSE)
  x=1:length(unique(data_preprocessed$module_number))
  setEPS()
  if(var=='m')
  {
    postscript("Cluster_cmeans_males.eps")
    plot(1,pch=".",col="white",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab="Module number",ylab="Users",main="Male users clustered by courseware access using C-means clustering")
  }else if(var=='f')
  {
    postscript("Cluster_cmeans_females.eps")
    plot(1,pch=".",col="white",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab="Module number",ylab="Users",main="Female users clustered by courseware access using C-means clustering")
  }else
  {
    postscript("Cluster_cmeans_all_users.eps")
    plot(1,pch=".",col="white",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab="Module number",ylab="Users",main="All users clustered by courseware access using C-means clustering")
  }
  par(new=T)
  for(k in cluster_order)
  {
    #Subset of students belonging to cluster_id=k
    temp=subset(data_access,data_access$cluster_id==k)
    #for loop iterating over every clickstream event in subset obtained above
    for(j in 1:nrow(temp))
    {
      stud_id=temp$temp_student_id[j]
      temp2=subset(data_preprocessed,data_preprocessed$temp_student_id==stud_id)
      access_list=rep(NA,length(unique(data_preprocessed$module_number)))
      for(i in 1:length(access_list))
      {
        if(i %in% temp2$module_number)
        {
          access_list[i]=i
        }
      }
      #plot each cluster (from 1 to a maximum of 10) using a different color
      if(k==1)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="red",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==2)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="blue",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==3)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="black",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==4)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="green",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==5)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="yellow",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==6)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="pink",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==7)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="orange",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==8)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="brown",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==9)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="darkgrey",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
      else if(k==10)
      {
        plot(x=access_list,y=rep(counter,length(access_list)),pch=".",col="cyan",xlim=c(0,length(unique(data_preprocessed$module_number))),ylim=c(0,max(data_access$temp_student_id)),xlab=" ",ylab=" ",axes=F)
        par(new=T)
        counter=counter+1
      }
    }
  }
  dev.off()
  print("Done! The results of hypothesis testing on access events between clusters: ",quote=FALSE)
  #Kruskal-Wallis test to show that clustering is statistically significant
  Krus_Wal=kruskal.test(data_access$number_accesses~data_access$cluster_id,data=data_access)
  print(paste("P-value for Kruskal-Wallis test for access events between clusters is ",Krus_Wal$p.value,"..."),quote=FALSE)
  #Mann-Whitney-Wilcoxon test to test if clusters are pair-wise distinct 
  counter=0
  for(i in 1:(K-1))
  {
    for(j in (i+1):K)
    {
      data_subset=subset(data_access,data_access$cluster_id==i | data_access$cluster_id==j)
      Mann_Whit=wilcox.test(data_subset$number_accesses~data_subset$cluster_id,data=data_subset)
      if(Mann_Whit$p.value>0.01)
      {
        print(paste("Clusters ",i," and ",j," are not statistically significant (using p-value threshold of 0.01)..."),quote=F)
      }
      else
      {
        counter=counter+1
      }
    }
  }
  #(K choose 2) pairings, if counter = (K choose 2), all clusters are pairwise significant
  if(counter==(K*(K-1)/2))
  {
    print("All clusters are pairwise distinct, i.e. has p-value less than 0.01...",quote=F)
  }
  #Clear all variables
  rm(list=ls())
  
} else
{
  print("Invalid choice! Please enter 1 or 2...",quote=FALSE)
}