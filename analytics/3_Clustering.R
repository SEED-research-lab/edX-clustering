## ===================================================== ##
# Title:        Clustering users based on course module interaction ####
# Project:      edX data pipeline for course user clustering analytics
#               https://tzwilliams.github.io/edX-clustering/
# 
# Copyright 2017 Krishna Madhavan
# 
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#     
#     http://www.apache.org/licenses/LICENSE-2.0
#     
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
#
# Authors:      Krishna Madhavan, Kerrie Douglas, Doipayan Roy, and Taylor Williams
# Affiliation:  Purdue University
# 
# Description:  This program uses the preprocessed_data.csv file generated by 2_preprocessing.R 
#                 (and the one generated by 2b_genderedSubsets.R if M/F analysis selected)
#               2_preprocessing.R (and 2b_genderedSubsets.R) has to be run before this program is 
#                 executed preprocessed_data.csv (or preprocessed_data_females.csv or 
#                 preprocessed_data_males.csv) is read as the dataFrame object named data.
# 
# 
# File input stack: 
#       preprocessed_data.csv         (source: pipeline script 2_Preprocessing.R)
#       preprocessed_data_females.csv (source: pipeline script 2b_genderedSubsets.R)
#       preprocessed_data_males.csv   (source: pipeline script 2b_genderedSubsets.R)
# 
# 
# Package dependencies: readr, cluster, e1071, [tcltk, #beepr]
#
# Changelog:
#     2017.04.13    Added gendered clickstream user choices
#                   Changed gap plots to only go up to 10 clusters (previously was set to 20 clusters)
#     2017.05.03.   Input files read from subdirectory
#                   Created output files placed into a separate subdirectory
#     2017.05.03.   Put subdirectory and file checking code into functions
#     2017.05.08.   Code cleaning, header update
#                   Audio notification for user input and script completion (using '#beepr' package)
#                   Plot output files set to PDF (had been EPS)
#                   Output filenames and plot subtitles are now descriptive 
#                    (using the user provided description)
#     2017.05.10.   Fuzzy code updated to match updates above (which had only been to the k-means code)
#                   Added valid user input check for clustering technique selection
#     2017.05.11.   Extracted possible functions to external files
#     2017.06.10.   Integrated Doipayan's modifications up through 2017.05.09 
#                   Added timer to track script execution time
#                   Code optimizations
#     2017.07.14.   Minor code updates; added copyright information
#     2017.08.06.   Update to comments; spell check
#     2017.08.10.   Update to figure titles
#     2017.11.08.   Moved ordering clusters and plotting clusters in to external functions
#                   
# Feature wish list:  (*: planned but not complete)
#                   *Comment out dependencies on "progress" package
#                   *Add in more basic (package independent) progress indicator
#                   *add option to generate all plots (All clustering techniques, all users subsets)
## ===================================================== ##



######### Clean the environment ########## 
rm(list=ls())   


######### Internal functions ########## 
#Function: Interactively select working directory (OS independent, but not available for RStudio Server)
InteractiveSetWD <- function() {
  cat("IMPORTANT: Select your working directory. If a folder choice window doesn't appear, look for it behind your current window.")
  setwd('~')
  #tcltk package provides an OS independent way to select a folder
  library(tcltk)
  #setting the arguments (see package documentation for details)
  .tcl.objv  <- .Tcl.args.objv('-initialdir "~" -title "Choose a working directory"')
  # open a folder selection window (defaults to 'My Documents').  Sometimes this opens in the background.
  dir <- tclvalue(tkchooseDirectory()) 
  setwd(dir)
  
  return() 
}


#Function: Check to see if the current working directory contains an expected file.  
# If not then prompt user to select the correct directory
WorkingDirectoryCheck <- function(expectedFile) {
  #set directory variables
  curDir <- getwd()
  
  
  if(file.exists(file.path(curDir, expectedFile))){
    #if file does exists in the current WD, exit the function returning TRUE
    return(TRUE)
  } else{
    #if the file does not exist in the current WD, return FALSE
    return(FALSE)
  }
}


# end of functions
## *************************************** #####
# begin script setup


######### Check for correct working directory ########## 
#check for correct expected working directory, inform user if incorrect and stop running script
current.dir <- getwd()
thisFile = "3_Clustering.R"
expectedFile = file.path(thisFile)

if(!WorkingDirectoryCheck(expectedFile)){
  message("\nThe current working directory is NOT CORRECT.
          It is currently set to '", current.dir, "'
          Please set it to the directory containing the '", thisFile, 
          "' file and rerun this script.\n")
  
  #stop running current script
  break
}


######### External function sourcing ########## 
#load external functions
source("R/file-structure-functions.R")
source("R/OrderClusters.R")
source("R/PlotClusters.R")



# end of script setup
## *************************************** #####

## MAIN ####
# beginning of script functionality


#start a timer to track how long the script takes to execute
start <-  proc.time() #save the time (to compute elapsed time of script)



######### User providing dataset details #####
#beepr::beep(sound = 10)   #notify user to provide input
cat("\nEnter a description of this datasest (to be included on graphs).
    (suggested format: [Data source, e.g., edX], [Course number, e.g., nano515x], [Data date, e.g., Data from 2016.11.18])")
dataSetDescription <- readline(prompt="Description: ");



######### Choose clustering technique #######################################################
#Choose clustering method (repeating to sanitize user input)
repeat{
  #beepr::beep(sound = 10)   #notify user to provide input
  clusterTypeSelection <- readline(prompt="Enter '1' for K-means clustering, '2' for C-means (fuzzy) clustering: ");
  
  if(clusterTypeSelection == 1 || clusterTypeSelection == 2){  #valid clustering method selected
    #exit loop and continue script
    break
  }
  
  #repeat if none of the conditions were met (i.e., user input was invalid)
}


######### User selection of data set to process #####
#Choose clickstream data(sub)set (repeating to sanitize user input).  With valid input
#  save the file paths needed later for clustering
repeat{
  #beepr::beep(sound = 10)   #notify user to provide input
  userSubsetSelection <- readline(prompt="Enter '1' for all learners, 
      '2' or 'f' for female learners, 
      '3' or 'm' for male learners: ");
  
  if(userSubsetSelection == 1){  #dataset: all learners
    dataSetName <- "all learners"
    #check for preprocessed datafile existence
    preprocessedDataFilePath <- FileExistCheck(subDir = "2_PreprocessingOutput", 
                                               filename = "preprocessed_data.csv")
    #exit script if file not found, otherwise continue
    ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")
    
    #check for user access datafile existence
    #TW:bug:the file has not yet been created.  It happens some dozen lines down
    #   accessDataFilePath <- FileExistCheck(subDir = "3_ClusteringOutput", filename = "access_data.csv")
    # 	#exit script if file not found, otherwise continue
    #   ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")
    
    
    break
  }
  else if(userSubsetSelection == "f" || #dataset: female learners
          userSubsetSelection == "F" || 
          userSubsetSelection == 2){  
    dataSetName <- "female learners"
    #set subset selection variable to a known value for future use
    userSubsetSelection <- "f"
    #check for preprocessed datafile existance
    preprocessedDataFilePath <- FileExistCheck(subDir = "2_PreprocessingOutput", 
                                               filename = "preprocessed_data_females.csv")
    #exit script if file not found, otherwise continue
    ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")
    
    #check for user access datafile existence
    #TW:bug:the file has not yet been created.  It happens some dozen lines down
    # 	accessDataFilePath <- FileExistCheck(subDir = "3_ClusteringOutput", filename = "access_data_females.csv")
    # 	#exit script if file not found, otherwise continue
    #   ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")
    
    
    break
  }
  else if(userSubsetSelection == "m" || userSubsetSelection == "M" || userSubsetSelection == 3){  #dataset: male learners
    dataSetName <- "male learners"
    #set subset selection variable to a known value for future use
    userSubsetSelection <- "m"
    #check for preprocessed datafile existence
    preprocessedDataFilePath <- FileExistCheck(subDir = "2_PreprocessingOutput", filename = "preprocessed_data_males.csv")
    #exit script if file not found, otherwise continue
    ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")
    
    #check for user access datafile existence
    #TW:bug:the file has not yet been created.  It happens some dozen lines down
    # 	accessDataFilePath <- FileExistCheck(subDir = "3_ClusteringOutput", filename = "access_data_males.csv")
    # 	#exit script if file not found, otherwise continue
    #   ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")
    
    break
  }
  
  #repeat if none of the conditions were met (i.e., user input was invalid)
}

## Read data and retain needed columns
#read in data from the appropriate learner (sub)set
data_preprocessed <- readr::read_csv(preprocessedDataFilePath)

##retain relevant columns
data_preprocessed <- data_preprocessed[names(data_preprocessed) %in% c("temp_student_id","module_number","time")]
##Ordering dataframe by student_id column
data_preprocessed <- data_preprocessed[order(data_preprocessed$temp_student_id,decreasing=F),]



######### Save the current working directory ##########  
# Set the output directory to the working directory. (wd will be restored at the end of the script)

#save current working directory
initialWD_save <- getwd()


#call function to check for the existence of the subdirectory; create it if it doesn't exist
subDirPath <- DirCheckCreate(subDir = "3_ClusteringOutput")

#set working directory for the remainder of the script
setwd(subDirPath)


## ===================================================== ##


######### Calculating number of unique module accesses for each student and saving to file########

cat("\nCalculating number of access events for each learner...")
#access_list contains the number of unique module accesses for each learner
access_list <- c()
for(i in 1:length(unique(data_preprocessed$temp_student_id)))
{
  temp <- subset(data_preprocessed,data_preprocessed$temp_student_id==i)
  access_list <- c(access_list,nrow(temp))
}
cat("\nDone! Saving to file...")
#data_access contains the columns required for clustering
data_access <- data.frame(1:length(unique(data_preprocessed$temp_student_id)),access_list)
#Renaming columns and writing to file
names(data_access) <- c("temp_student_id","number_accesses")
data_access <- data_access[names(data_access) %in% c("temp_student_id","number_accesses")]


#save the appropriate access data CSV
if(userSubsetSelection=='m')
{
  write.csv(data_access,"access_data_males.csv")
} else if(userSubsetSelection=='f')
{
  write.csv(data_access,"access_data_females.csv")
} else
{
  write.csv(data_access,"access_data.csv")
  
}

## ===================================================== ##
#Clearing all variables except those needed later
rm(list=setdiff(ls(), c('initialWD_save', 'userSubsetSelection', 'preprocessedDataFilePath', 
                        'data_access', 'data_preprocessed', 'clusterTypeSelection', 'clusterTypeName',
                        'dataSetDescription', 'dataSetName', 'start')))


######### If k-means clustering chosen ######################################################

if(clusterTypeSelection==1)
{
  ##Set label
  clusterTypeName <- "k-means clustering"
  
  ##TW:ver:the following should be unnecessary
  # ##Read access data file and delete irrelevant columns
  # if(userSubsetSelection=='m')
  # {
  #   data_access <- read.csv("access_data_males.csv",header=T)
  # } else if(userSubsetSelection=='f')
  # {
  #   data_access <- read.csv("access_data_females.csv",header=T)
  # } else
  # {
  #   data_access <- read.csv("access_data.csv",header=T)
  # }
  # data_access <- as.data.frame(data_access)
  # data_access <- data_access[names(data_access) %in% c("temp_student_id","number_accesses")]
  
  ## **Generate elbow plot from access data using K=1 to K=10 (K = number of clusters) ####
  cat("\nGenerating elbow plot...")
  
  #elbow_plot_values is a list of betweenClusterSumofSquares/totalSumofSquares for K = 1 to 10
  elbow_plot_values <- c()
  for(k in 1:10)
  {
    K_m <- kmeans(data_access$number_accesses,centers=k,iter.max=50,algorithm="Lloyd")
    elbow_plot_values <- c(elbow_plot_values,K_m$betweenss/K_m$totss)
  }
  ##Plot elbow plot
  
  #set the range of x values to include in the plot
  x=1:10
  pdf.options(reset = TRUE)
  #set the PDF name
  pdf(paste0(dataSetDescription, ". ", dataSetName, ". ", "k-means_elbow_plot.pdf"))  
  #create plot option (including descriptive subtitle)
  plot(x = x, y = elbow_plot_values, col="blue", type="l",
       xlim=c(0,10), ylim=c(0,1.2), xlab="Number of clusters",
       ylab="Between cluster sum of squares / Total sum of squares",
       main=paste0("Elbow plot for ", dataSetName,"\n", 
                   clusterTypeName, "\n",
                   dataSetDescription))
  
  dev.off()
  cat("\nDone!")
  
  
  ## **Generate gap plot from access data for K = 1 to 10 (K = number of clusters)####
  cat("\nGenerating gap plot...")
  gap_statistic <- cluster::clusGap(as.matrix(data_access$number_accesses),K.max=10,FUN=kmeans,verbose=FALSE)
  gap_values <- (as.data.frame(gap_statistic$Tab))$gap
  #set the range of x values to include in plot
  x=1:10
  pdf.options(reset = TRUE)
  #set the PDF name
  #Simple name (to delete): pdf("gap_plot.pdf")
  pdf(paste0(dataSetDescription, ". ", dataSetName, ". ", "k-means_gap_plot.pdf"))
  #set plot options (including descriptive subtitle)
  plot(x = x, y = gap_values, col="black", xlim = c(0,10), ylim = c(0,1),
       xlab="Number of clusters", ylab="Gap", type="l",
       main = paste0("Gap plot for ", dataSetName,"\n", 
                     clusterTypeName, "\n",
                     dataSetDescription))
  #close the PDF creation connection
  dev.off()
  cat("\nDone!")
  
  ## **Make recommendations for cluster number ####
  ##Make recommendation for number of clusters based on elbow plot (once delta is less than 2%)
  for(i in 3:10)
  {
    #Calculate percentage increase in explained variance from k to k+1 clusters
    percent_inc=(elbow_plot_values[i]-elbow_plot_values[i-1])/elbow_plot_values[i-1]
    if(percent_inc<0.02)
    {
      print(paste("Recommendation for number of clusters using elbow plot:",i-1))
      break
    }
  }
  
  ##Make recommendation for number of clusters based on gap statistics (first peak in plot)
  optimal_clusters <- c()
  counter <- 0
  for(i in 2:9)
  {
    if(gap_values[i-1]<gap_values[i] & gap_values[i+1]<gap_values[i])
      # {			##TW: ??: ask DR why this was removed and only one recommendation is now being provided.  If this is removed then why even solicit user input on number of clusters?  If it is removed then delete the extra variables above the "for".
      # optimal_clusters=c(optimal_clusters,i)
      # counter <- counter+1
      # }
      # if(counter==2)
      # {
      # print(paste("Recommendation for number of clusters using gap statistics:",
      # optimal_clusters[1],"or",optimal_clusters[2]))
      # break
      # }
    {
      print(paste("Recommendation for number of clusters using gap statistics:",i),quote=FALSE)
      
      break
    }
  }
  
  #Clearing all variables except those needed later
  rm(list=setdiff(ls(), c('initialWD_save', 'userSubsetSelection', 'preprocessedDataFilePath', 
                          'data_access', 'data_preprocessed', 'clusterTypeSelection', 'clusterTypeName',
                          'dataSetDescription', 'dataSetName', 'start')))
  
  
  ##Get user input for number of clusters
  #beepr::beep(sound = 10)   #notify user to provide input
  K <- readline("Enter the desired number of clusters (maximum 10): ");
  K <- as.integer(K);
  
  #Ordering data_access in increasing order of temporary student it (integer id created for each student in preprocessing)
  data_access <- data_access[order(data_access$temp_student_id,decreasing=F),]
  
  
  #Performing K-means clustering on access data using user's choice of K
  K_m <- kmeans(data_access$number_accesses,centers=K,iter.max=100,algorithm="Lloyd")
  cluster_id <- K_m$cluster
  
  #Binding cluster_id of each student to data_access
  data_access <- cbind(data_access,cluster_id)
  
  #Ordering data_access in increasing order of number of unique accesses of students
  data_access <- data_access[order(data_access$number_accesses,decreasing=F),]
  

  # #Clearing all variables except those needed later
  # rm(list=setdiff(ls(), c('initialWD_save', 'userSubsetSelection', 'preprocessedDataFilePath', 
  #                         'data_access', 'data_preprocessed', 'clusterTypeSelection', 'clusterTypeName',
  #                         'dataSetDescription', 'dataSetName', 'start')))
  
  ######### If c-means (fuzzy means) chosen #####################################################
} else if(clusterTypeSelection==2)
{
  
  ##Set label
  clusterTypeName <- "C-means (fuzzy) clustering"
  
  ## **Generate gap plot from access data for K = 1 to 10 (K = number of clusters) ####
  cat("\nGenerating gap plot...")
  gap_statistic <- cluster::clusGap(as.matrix(data_access$number_accesses),K.max=10,FUN=kmeans,verbose=FALSE)   #TW:??:for DR??? should kmeans be the FUN used here?  We're in the c-means clustering section
  gap_values <- (as.data.frame(gap_statistic$Tab))$gap
  
  #Plot gap plot
  #set the range of x values to include in the plot
  x <- 1:10
  #set the PDF name
  pdf(paste0(dataSetDescription, ". ", dataSetName, ". ", "c-means_gap_plot.pdf"))
  #set plot options (including descriptive subtitle)
  plot(x = x,y = gap_values,col="black",xlim=c(0,10),ylim=c(0,1),
       xlab="Number of clusters",ylab="Gap",type="l",
       main = paste0("Gap plot for ", dataSetName,"\n", 
                     clusterTypeName, "\n",
                     dataSetDescription))
  #close the PDF creation connection
  dev.off()
  cat("\nDone!")
  
  ## **Make recommendation for number of clusters based on gap statistics (first peak in plot) ####
  optimal_clusters <- c()
  counter <- 0
  for(i in 2:9)
  {
    if(gap_values[i-1]<gap_values[i] & gap_values[i+1]<gap_values[i])
      # {    #TW:??: same question for DR as above in k-means section.  Why eliminate the two calculated.  Why give user the choice?
      # optimal_clusters=c(optimal_clusters,i)
      # counter <- counter+1
      # }
      # if(counter==2)
      # {
      # print(paste("Recommendation for number of clusters using gap statistics:",optimal_clusters[1],"or",optimal_clusters[2]))
      # break
      # }
    {
      print(paste("Recommendation for number of clusters using gap statistics:",i),quote=FALSE)
      break
    }
  }
  
  #Clearing all variables except those needed later
  rm(list=setdiff(ls(), c('initialWD_save', 'userSubsetSelection', 'preprocessedDataFilePath', 
                          'data_access', 'data_preprocessed', 'clusterTypeSelection', 'clusterTypeName',
                          'dataSetDescription', 'dataSetName', 'start')))
  
  ##User input for number of clusters
  #beepr::beep(sound = 10)   #notify user to provide input
  K <- readline("Enter the desired number of clusters (maximum 10): ");
  K <- as.integer(K);
  
  
  
  #Ordering data_access in increasing order of temporary student it (integer id created for each student in preprocessing)
  data_access <- data_access[order(data_access$temp_student_id,decreasing=F),]
  #Performing C-means clustering on access data using user's choice of K clusters
  C_m <- e1071::cmeans(as.matrix(data_access$number_accesses),centers=K)
  cluster_id <- C_m$cluster
  #Binding cluster_id of each student to data_access
  data_access <- cbind(data_access,cluster_id)
  #Ordering data_access in increasing order of number of unique accesses of students
  data_access <- data_access[order(data_access$number_accesses,decreasing=F),]
  

} else
{
  print("Invalid choice! Please enter 1 or 2...")
}

## Ordering clusters ####
#Ordering clusters in decreasing order of accesses, heaviest user cluster comes first 
#  cluster_order contains the cluster_id's ordered in increasing order of access activity
source("../R/OrderClusters.R")
cluster_order <- OrderClusters(data_access = data_access, 
                               K = K)


## Plotting clusters ####
source("../R/PlotClusters.R")
PlotClusters(clusterTypeName = clusterTypeName, 
             K = K, 
             data_preprocessed = data_preprocessed, 
             data_access = data_access, 
             access_list =  access_list, 
             cluster_order = cluster_order, 
             dataSetName = dataSetName, 
             dataSetDescription = dataSetDescription)




# Significance tests ####
  # Kruskal-Wallis test to show that clustering is statistically significant
  cat("\n\nThe results of hypothesis testing on access events between clusters: ")
  
  Krus_Wal <- kruskal.test(data_access$number_accesses~data_access$cluster_id,data=data_access)
  cat("\nP-value for Kruskal-Wallis test for access events between clusters is ",Krus_Wal$p.value,"...")
  
  # Mann-Whitney-Wilcoxon test to test if clusters are pair-wise distinct
  counter=0
  for(i in 1:(K-1))
  {
    for(j in (i+1):K)
    {
      data_subset <- subset(data_access,data_access$cluster_id==i | data_access$cluster_id==j)
      Mann_Whit <- wilcox.test(data_subset$number_accesses~data_subset$cluster_id,data=data_subset)
      if(Mann_Whit$p.value>0.01)
      {
        cat("\nClusters ",i," and ",j," are not statistically significant (using p-value threshold of 0.01)...")
      }
      else
      {
        counter <- counter+1
      }
    }
  }
  #(K choose 2) pairings, if counter = (K choose 2), all clusters are pairwise significant
  if(counter==(K*(K-1)/2))
  {
    cat("\nAll clusters are pairwise distinct, i.e. has p-value less than 0.01...")
  }


## Restore the working directory from when the script began
setwd(initialWD_save)



######### Notify user and clear the environment  #############
# beepr::beep(sound = 10)   #notify user script is complete
# Sys.sleep(time = 0.1)     #pause 1/10 sec
# beepr::beep(sound = 10)
# Sys.sleep(time = 0.1)
# beepr::beep(sound = 10)

#print the amount of time the script required
cat("\n\n\nScript (3_Clustering.R) processing time details (in sec):\n")
print(proc.time() - start)

rm(list=ls())   #Clear environment variables

