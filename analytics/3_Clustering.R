## ===================================================== ##
# Title:        Clustering users based on course module interaction ####
# Project:      edX data pipeline for course user clustering analytics
#               https://tzwilliams.github.io/edX-clustering/
#
# Copyright 2017 Krishna Madhavan
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
#
# Authors:      Krishna Madhavan, Kerrie Douglas, Doipayan Roy, and Taylor Williams
# Affiliation:  Purdue University
#
# Description: *  This program uses the preprocessed_data.csv file generated by 
#               2_preprocessing.R (and the one generated by 2b_genderedSubsets.R 
#               if M/F analysis selected). 
#              *  2_preprocessing.R (and optionally 2b_genderedSubsets.R) must be 
#               run before this program is executed. 
#              *  preprocessed_data.csv (and/or preprocessed_data_females.csv 
#               and/or preprocessed_data_males.csv) is read in as the dataFrame 
#               object named 'data'
#
#
# File input stack (R: required; O: optional):
#     R:  preprocessed_data.csv         (source: pipeline script 2_Preprocessing.R)
#     O:  preprocessed_data_females.csv (source: pipeline script 2b_genderedSubsets.R)
#     O:  preprocessed_data_males.csv   (source: pipeline script 2b_genderedSubsets.R)
#     O:  UIDs_to_use.csv               (source: user provided; must have 'student_id' column)
#
# File outputs:
#       PDF figures: clustering plot, elbow plot, gap plot
#       CSV data: access data for all users, gender specified users, and cluster groups
#
# Package dependencies: readr, cluster, e1071, dplyr, [tcltk, #beepr]
#
# Changelog:
#     2017.04.13    Added gendered clickstream user choices
#                   Changed gap plots to only go up to 10 clusters (previously 
#                     was set to 20 clusters)
#     2017.05.03.   Input files read from subdirectory
#                   Created output files placed into a separate subdirectory
#     2017.05.03.   Put subdirectory and file checking code into functions
#     2017.05.08.   Code cleaning, header update
#                   Audio notification for user input and script completion 
#                     (using '#beepr' package)
#                   Plot output files set to PDF (had been EPS)
#                   Output filenames and plot subtitles are now descriptive
#                    (using the user provided description)
#     2017.05.10.   Fuzzy code updated to match updates above (which had only 
#                     been to the k-means code)
#                   Added valid user input check for clustering technique selection
#     2017.05.11.   Extracted possible functions to external files
#     2017.06.10.   Integrated Doipayan's modifications up through 2017.05.09
#                   Added timer to track script execution time
#                   Code optimizations
#     2017.07.14.   Minor code updates; added copyright information
#     2017.08.06.   Update to comments; spell check
#     2017.08.10.   Update to figure titles
#     2017.11.08.   Moved ordering clusters and plotting clusters in to external functions
#                   Saving CSV files for each cluster with userID values
#     2018.03.26.   Update to how validation p-values are printed and saved
#     2018.04.17.   Add option for user to provide a list of UIDs by which to 
#                     filter the users included in plot
#
# Feature wish list:  (*: planned but not complete)
#                   *Comment out dependencies on "progress" package
#                   *Add in more basic (package independent) progress indicator
#                   *add option to generate all plots (All clustering techniques, all users subsets)
#                   *save the suggested cluster # (gap and elbow) to file for ref.
## ===================================================== ##



######### Clean the environment ##########
rm(list=ls())


######### Internal functions ##########
#Function: Interactively select working directory (OS independent, but not available for RStudio Server)
InteractiveSetWD <- function() {
  cat("IMPORTANT: Select your working directory. If a folder choice window doesn't appear, look for it behind your current window.")
  setwd('~')
  #tcltk package provides an OS independent way to select a folder
  library(tcltk)
  #setting the arguments (see package documentation for details)
  .tcl.objv  <- .Tcl.args.objv('-initialdir "~" -title "Choose a working directory"')
  # open a folder selection window (defaults to 'My Documents').  Sometimes this opens in the background.
  dir <- tclvalue(tkchooseDirectory())
  setwd(dir)

  return()
}


#Function: Check to see if the current working directory contains an expected file.
# If not then prompt user to select the correct directory
WorkingDirectoryCheck <- function(expectedFile) {

  if(file.exists(file.path(getwd(), expectedFile))){
    #if file does exists in the current WD, exit the function returning TRUE
    return(TRUE)
  } else{
    #check for likely locations, set wd automatically if found and return TRUE
    if(file.exists(file.path(getwd(), "analytics", expectedFile))){
      setwd(file.path(getwd(), "analytics"))
      return(TRUE)
    } else if(file.exists(file.path(dirname(getwd()), expectedFile))){
      setwd(dirname(getwd()))   #set wd to parent directory of current wd
      return(TRUE)
    } else{
      #return FALSE if the file does not exist in the current WD (or other obvious locations)
      return(FALSE)
    }
  }
}


# end of functions
## *************************************** #####
# begin script setup


######### Check for correct working directory ##########
#check for correct expected working directory, inform user if incorrect and stop running script
current.dir <- getwd()
thisFile = "3_Clustering.R"
expectedFile = file.path(thisFile)

if(!WorkingDirectoryCheck(expectedFile)){
  message("\nThe current working directory is NOT CORRECT.
          It is currently set to '", current.dir, "'
          Please set it to the directory containing the '", thisFile,
          "' file and rerun this script.\n")

  #stop running current script
  break
}


######### Load required libraries ##########
require("dplyr")



######### External function sourcing ##########
#load external functions
source("R/file-structure-functions.R")
source("R/OrderClusters.R")
source("R/PlotClusters.R")

# end of script setup
## *************************************** #####



## MAIN ####
# beginning of script functionality


#start a timer to track how long the script takes to execute
start <-  proc.time() #save the time (to compute elapsed time of script)



######### User providing dataset details #####
beepr::beep(sound = 10)   #notify user to provide input
cat("\nEnter a description of this datasest (to be included on graphs).
    (suggested format: [Data source, e.g., edX], [Course number, e.g., nano515x], [Data date, e.g., Data from 2016.11.18])")
dataSetDescription <- readline(prompt="Description: ");



######### Choose clustering technique ##########################################
#Choose clustering method (repeating to sanitize user input)
repeat{
  beepr::beep(sound = 10)   #notify user to provide input
  clusterTypeSelection <- readline(prompt="Enter '1' for K-means clustering, '2' for c-means (fuzzy) clustering: ");

  if(clusterTypeSelection == 1 || clusterTypeSelection == 2){  #valid clustering method selected
    #exit loop and continue script
    break
  }

  #repeat if none of the conditions were met (i.e., user input was invalid)
}


######### User selection of data set to process #####
#Choose clickstream data(sub)set (repeating to sanitize user input).  With valid input
#  save the file paths needed later for clustering
repeat{
  userIDsToInclude <- as.numeric(NULL)  #create empty list of userIDs
  
  beepr::beep(sound = 10)   #notify user to provide input
  userSubsetSelection <- readline(prompt="Enter '1' for all learners,
      '2' or 'f' for female learners,
      '3' or 'm' for male learners,
      '4' or 'c' to provide a custom ID list: ");

  if(userSubsetSelection == 1){  #dataset: all learners
    dataSetName <- "all"
    #check for preprocessed datafile existence
    preprocessedDataFilePath <- FileExistCheck(subDir = "2_PreprocessingOutput",
                                               filename = "preprocessed_data.csv")
    #exit script if file not found, otherwise continue
    ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")

    #check for user access datafile existence
    #TODO(TW:bug):the file has not yet been created.  It happens some dozen lines down
    #   accessDataFilePath <- FileExistCheck(subDir = "3_ClusteringOutput", filename = "access_data.csv")
    # 	#exit script if file not found, otherwise continue
    #   ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")


    break
  }
  else if(userSubsetSelection == "f" || #dataset: female learners
          userSubsetSelection == "F" ||
          userSubsetSelection == 2){
    dataSetName <- "females"
    #set subset selection variable to a known value for future use
    userSubsetSelection <- "f"
    #check for preprocessed datafile existance
    preprocessedDataFilePath <- FileExistCheck(subDir = "2_PreprocessingOutput",
                                               filename = "preprocessed_data_females.csv")
    #exit script if file not found, otherwise continue
    ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")

    #check for user access datafile existence
    #TODO(TW:bug):the file has not yet been created.  It happens some dozen lines down
    # 	accessDataFilePath <- FileExistCheck(subDir = "3_ClusteringOutput", filename = "access_data_females.csv")
    # 	#exit script if file not found, otherwise continue
    #   ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")


    break
  }
  else if(userSubsetSelection == "m" ||
          userSubsetSelection == "M" ||
          userSubsetSelection == 3){  #dataset: male learners
    dataSetName <- "male"
    #set subset selection variable to a known value for future use
    userSubsetSelection <- "m"
    #check for preprocessed datafile existence
    preprocessedDataFilePath <- FileExistCheck(subDir = "2_PreprocessingOutput",
                                               filename = "preprocessed_data_males.csv")
    #exit script if file not found, otherwise continue
    ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")

    #check for user access datafile existence
    #TODO(TW:bug):the file has not yet been created.  It happens some dozen lines down
    # accessDataFilePath <- FileExistCheck(subDir = "3_ClusteringOutput", 
    #                                      filename = "access_data_males.csv")
    # 	#exit script if file not found, otherwise continue
    #   ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")

    break
  }
  else if(userSubsetSelection == "c" || #dataset: custom learner set (user provided)
          userSubsetSelection == "C" ||
          userSubsetSelection == 4){
    dataSetName <- "custom learner set"
    #set subset selection variable to a known value for future use
    userSubsetSelection <- "c"


    #get UID list from user
      #Locate the user list csv data file (with sanitized user input)
      repeat{
        prompt <- "*****Select a CSV file with the student_id values to cluster.*****  \n     (The IDs need to be in a column named 'student_id'.)"
        message("\n", prompt)
        #beepr::beep(sound = 10)   #notify user to provide input
        # filenameJSON <- file.choose() #commented out, but may still be needed if working in RStudio server environment
        filenameUserFilter <- tcltk::tk_choose.files(caption = prompt,
                                               default = ".csv",
                                               filter = matrix(c("CSV", ".csv"), 1, 2, byrow = TRUE),
                                               multi = FALSE)
        
        #read in the file, return the column names, 
        #   check to see if each column matches "student_id", 
        #   add the boolean results (if a maching column exists the result 
        #   will be 1, if not the result will be 0)
        fileContentsCheck <- sum(names(read.csv(filenameUserFilter))=="student_id")

        # continue if the user provided file contains the expected column
        if(fileContentsCheck == 1){
          # read list
          userIDsToInclude <- read.csv(filenameUserFilter)$student_id
          
          # break repeat loop, and continue with script
          break
        }else{
          #repeat file selection loop
        }
      }

    
    #check for preprocessed datafile existance
    preprocessedDataFilePath <- FileExistCheck(subDir = "2_PreprocessingOutput",
                                               filename = "preprocessed_data.csv")
    #exit script if file not found, otherwise continue
    ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")

    #check for user access datafile existence
    #TODO(TW:bug):the file has not yet been created.  It happens some dozen lines down
    # 	accessDataFilePath <- FileExistCheck(subDir = "3_ClusteringOutput", filename = "access_data_females.csv")
    # 	#exit script if file not found, otherwise continue
    #   ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")
    
    
    break
  }
  

  #repeat if none of the conditions were met (i.e., user input was invalid)
}

## Read data and retain needed columns
#read in data from the appropriate learner (sub)set
data_preprocessed <- readr::read_csv(preprocessedDataFilePath)


##filter "preprocessed_data.csv" to only users on the UID list
  if(length(userIDsToInclude)>0){  #retain relevant users 
    #retain relevant users (if a custom filter list was provided)(if a custom filter list was provided)
    data_preprocessed <- data_preprocessed[data_preprocessed$student_id %in% 
                                             userIDsToInclude,]
  }


##retain relevant columns
data_preprocessed <- data_preprocessed[names(data_preprocessed) %in% 
                                         c("student_id", 
                                           "temp_student_id",
                                           "module_number",
                                           "time")]
##Ordering dataframe by temp_student_id column
data_preprocessed <- data_preprocessed[order(data_preprocessed$temp_student_id,
                                             decreasing=F),]



######### Save the current working directory ##########
# Set the output directory to the working directory. (wd will be restored at the end of the script)

#save current working directory
initialWD_save <- getwd()


#call function to check for the existence of the subdirectory; create it if it doesn't exist
subDirPath <- DirCheckCreate(subDir = "3_ClusteringOutput")

#set working directory for the remainder of the script
setwd(subDirPath)


## ===================================================== ##


######### Calculating number of unique module accesses for each student and saving to file########

cat("\nCalculating number of access events for each learner...")
#data_access contains the number of unique module accesses for each learner
data_access <- tibble(temp_student_id = as.numeric(),
                      number_accesses = as.numeric(),
                      student_id = as.numeric())

for(i in unique(data_preprocessed$temp_student_id)){
    temp <- subset(data_preprocessed,data_preprocessed$temp_student_id == i)
    data_access <- add_row(data_access,
                         temp_student_id = temp$temp_student_id[1],
                         number_accesses = nrow(temp),
                         student_id = temp$student_id[1])
}
cat("\nDone! Saving to file...")


#save the appropriate access data to a CSV file
  write.csv(x = data_access,
            file = paste0("access_data. ", dataSetName, ".csv"),
            row.names = FALSE)


## ===================================================== ##
#Clearing all variables except those needed later
# rm(list=setdiff(ls(), c('initialWD_save', 'userSubsetSelection', 'preprocessedDataFilePath',
#                         'data_access', 'data_preprocessed', 'clusterTypeSelection', 'clusterTypeName',
#                         'dataSetDescription', 'dataSetName', 'start')))


######### If k-means clustering chosen ######################################################

if(clusterTypeSelection==1)
{
  ##Set label
  clusterTypeName <- "k-means clustering"

  ##TW:ver:the following should be unnecessary
  # ##Read access data file and delete irrelevant columns
  # if(userSubsetSelection=='m')
  # {
  #   data_access <- read.csv("access_data_males.csv",header=T)
  # } else if(userSubsetSelection=='f')
  # {
  #   data_access <- read.csv("access_data_females.csv",header=T)
  # } else
  # {
  #   data_access <- read.csv("access_data.csv",header=T)
  # }
  # data_access <- as.data.frame(data_access)
  # data_access <- data_access[names(data_access) %in% c("temp_student_id","number_accesses")]

  ## **Generate elbow plot from access data using K=1 to K=10 (K = number of clusters) ####
  cat("\nGenerating elbow plot...")

  #elbow_plot_values is a list of betweenClusterSumofSquares/totalSumofSquares for K = 1 to 10
  elbow_plot_values <- c()
  for(k in 1:10)
  {
    K_m <- kmeans(data_access$number_accesses,
                  centers=k,
                  iter.max=50,
                  algorithm="Lloyd")
    elbow_plot_values <- c(elbow_plot_values,K_m$betweenss/K_m$totss)
  }
  ##Plot elbow plot

  #set the range of x values to include in the plot
  x=1:10
  pdf.options(reset = TRUE)
  #set the PDF name
  pdf(paste0(dataSetDescription, ". ", dataSetName, ". ", "k-means_elbow_plot.pdf"))
  #create plot option (including descriptive subtitle)
  plot(x = x, y = elbow_plot_values, col="blue", type="l",
       xlim=c(0,10), ylim=c(0,1.2), xlab="Number of clusters",
       ylab="Between cluster sum of squares / Total sum of squares",
       main=paste0("Elbow plot for ", dataSetName,"\n",
                   clusterTypeName, "\n",
                   dataSetDescription))

  dev.off()
  cat("\nDone!")


  ## **Generate gap plot from access data for K = 1 to 10 (K = number of clusters)####
  cat("\nGenerating gap plot...")
  gap_statistic <- cluster::clusGap(as.matrix(data_access$number_accesses),
                                    K.max=10,
                                    FUN=kmeans,
                                    verbose=FALSE)
  gap_values <- (as.data.frame(gap_statistic$Tab))$gap
  #set the range of x values to include in plot
  x=1:10
  pdf.options(reset = TRUE)
  #set the PDF name
  #Simple name (to delete): pdf("gap_plot.pdf")
  pdf(paste0(dataSetDescription, ". ", dataSetName, ". ", "k-means_gap_plot.pdf"))
  #set plot options (including descriptive subtitle)
  plot(x = x, y = gap_values, col="black", xlim = c(0,10), ylim = c(0,1),
       xlab="Number of clusters", ylab="Gap", type="l",
       main = paste0("Gap plot for ", dataSetName,"\n",
                     clusterTypeName, "\n",
                     dataSetDescription))
  #close the PDF creation connection
  dev.off()
  cat("\nDone!\n\n")

  ## **Make recommendations for cluster number ####
  ##Make recommendation for number of clusters based on elbow plot (once delta is less than 2%)
  for(i in 3:10)
  {
    #Calculate percentage increase in explained variance from k to k+1 clusters
    percent_inc=(elbow_plot_values[i]-elbow_plot_values[i-1])/elbow_plot_values[i-1]
    if(percent_inc<0.02)
    {
      print(paste("Recommendation for number of clusters using elbow plot:",i-1))
      break
    }
  }

  ##Make recommendation for number of clusters based on gap statistics (first peak in plot)
  optimal_clusters <- c()
  counter <- 0
  for(i in 2:9)
  {
    if(gap_values[i-1]<gap_values[i] & gap_values[i+1]<gap_values[i])
      # {			##TODO(TW: ??): ask DR why this was removed and only one recommendation is now being provided.  If this is removed then why even solicit user input on number of clusters?  If it is removed then delete the extra variables above the "for".
      # optimal_clusters=c(optimal_clusters,i)
      # counter <- counter+1
      # }
      # if(counter==2)
      # {
      # print(paste("Recommendation for number of clusters using gap statistics:",
      # optimal_clusters[1],"or",optimal_clusters[2]))
      # break
      # }
    {
      print(paste("Recommendation for number of clusters using gap statistics:",i),quote=FALSE)

      break
    }
  }

  #Clearing all variables except those needed later
  # rm(list=setdiff(ls(), c('initialWD_save', 'userSubsetSelection', 'preprocessedDataFilePath',
  #                         'data_access', 'data_preprocessed', 'clusterTypeSelection', 'clusterTypeName',
  #                         'dataSetDescription', 'dataSetName', 'start')))


  ##Get user input for number of clusters
  beepr::beep(sound = 10)   #notify user to provide input
  K <- readline("Enter the desired number of clusters (maximum 10): ");
  K <- as.integer(K);

  #Ordering data_access in increasing order of temporary student it (integer id created for each student in preprocessing)
  data_access <- data_access[order(data_access$temp_student_id,decreasing=F),]


  #Performing K-means clustering on access data using user's choice of K
  K_m <- kmeans(data_access$number_accesses,centers=K,iter.max=100,algorithm="Lloyd")
  cluster_id <- K_m$cluster

  #Binding cluster_id of each student to data_access
  data_access <- cbind(data_access,cluster_id)

  #Ordering data_access in increasing order of number of unique accesses of students
  data_access <- data_access[order(data_access$number_accesses,decreasing=F),]


  # #Clearing all variables except those needed later
  # rm(list=setdiff(ls(), c('initialWD_save', 'userSubsetSelection', 'preprocessedDataFilePath',
  #                         'data_access', 'data_preprocessed', 'clusterTypeSelection', 'clusterTypeName',
  #                         'dataSetDescription', 'dataSetName', 'start')))

  ######### If c-means (fuzzy means) chosen #####################################################
} else if(clusterTypeSelection==2)
{

  ##Set label
  clusterTypeName <- "c-means (fuzzy) clustering"

  ## **Generate gap plot from access data for K = 1 to 10 (K = number of clusters) ####
  cat("\nGenerating gap plot...")
  gap_statistic <- cluster::clusGap(as.matrix(data_access$number_accesses),
                                    K.max=10, FUN=kmeans, verbose=FALSE)   #TODO(TW:??):for DR??? should kmeans be the FUN used here?  We're in the c-means clustering section
  gap_values <- (as.data.frame(gap_statistic$Tab))$gap

  #Plot gap plot
  #set the range of x values to include in the plot
  x <- 1:10
  #set the PDF name
  pdf(paste0(dataSetDescription, ". ", dataSetName, ". ", "c-means_gap_plot.pdf"))
  #set plot options (including descriptive subtitle)
  plot(x = x,y = gap_values,col="black",xlim=c(0,10),ylim=c(0,1),
       xlab="Number of clusters",ylab="Gap",type="l",
       main = paste0("Gap plot for ", dataSetName,"\n",
                     clusterTypeName, "\n",
                     dataSetDescription))
  #close the PDF creation connection
  dev.off()
  cat("\nDone!")

  ## **Make recommendation for number of clusters based on gap statistics (first peak in plot) ####
  optimal_clusters <- c()
  counter <- 0
  for(i in 2:9)
  {
    if(gap_values[i-1]<gap_values[i] & gap_values[i+1]<gap_values[i])
      # {    #TODO(TW:??): same question for DR as above in k-means section.  Why eliminate the two calculated.  Why give user the choice?
      # optimal_clusters=c(optimal_clusters,i)
      # counter <- counter+1
      # }
      # if(counter==2)
      # {
      # print(paste("Recommendation for number of clusters using gap statistics:",optimal_clusters[1],"or",optimal_clusters[2]))
      # break
      # }
    {
      print(paste("Recommendation for number of clusters using gap statistics:",i),quote=FALSE)
      break
    }
  }

  #Clearing all variables except those needed later
  # rm(list=setdiff(ls(), c('initialWD_save', 'userSubsetSelection', 'preprocessedDataFilePath',
  #                         'data_access', 'data_preprocessed', 'clusterTypeSelection', 'clusterTypeName',
  #                         'dataSetDescription', 'dataSetName', 'start')))

  ##User input for number of clusters
  beepr::beep(sound = 10)   #notify user to provide input
  K <- readline("Enter the desired number of clusters (maximum 10): ");
  K <- as.integer(K);



  #Ordering data_access in increasing order of temporary student it (integer id created for each student in preprocessing)
  data_access <- data_access[order(data_access$temp_student_id,decreasing=F),]
  #Performing C-means clustering on access data using user's choice of K clusters
  C_m <- e1071::cmeans(as.matrix(data_access$number_accesses),centers=K)
  cluster_id <- C_m$cluster
  #Binding cluster_id of each student to data_access
  data_access <- cbind(data_access,cluster_id)
  #Ordering data_access in increasing order of number of unique accesses of students
  data_access <- data_access[order(data_access$number_accesses,decreasing=F),]


} else
{
  print("Invalid choice! Please enter 1 or 2...")
}

## Ordering clusters ####
#Ordering clusters in decreasing order of accesses, heaviest user cluster comes first
#  cluster_order contains the cluster_id's ordered in increasing order of access activity
source("../R/OrderClusters.R")
cluster_order <- OrderClusters(data_access = data_access,
                               K = K)


## Plotting clusters ####
source("../R/PlotClusters.R")
PlotClusters(clusterTypeName = clusterTypeName,
             K = K,
             data_preprocessed = data_preprocessed,
             data_access = data_access,
             cluster_order = cluster_order,
             dataSetName = dataSetName,
             dataSetDescription = dataSetDescription)

## Saving UserIDs for each cluster ####
counter <- length(cluster_order)  #a counter for indicating most to least engaged clusters

for(k in cluster_order)
{
  #extract the users who are in this cluster
  curClusterUsers <- subset(data_access,data_access$cluster_id==k)  
  #only retain necessisary columns
  curClusterUsers <- select(curClusterUsers, "temp_student_id", "number_accesses", "student_id")  

  if(counter == 1) {
    write.csv(x = curClusterUsers,
              paste0("access_data. ", dataSetName, ". cluster_", 
                     counter, " (of ", length(cluster_order), ") (most engaged).csv"),
              row.names = FALSE)
  }else {
    write.csv(x = curClusterUsers,
              paste0("access_data. ", dataSetName, ". cluster_", 
                     counter, " (of ", length(cluster_order), ").csv"),
              row.names = FALSE)
  }

  counter <- counter - 1
}



# Significance tests ####
  # Kruskal-Wallis test to show that clustering is statistically significant
  cat("\n\nThe results of hypothesis testing on access events between clusters: ")
  
  Krus_Wal <- kruskal.test(data_access$number_accesses ~ data_access$cluster_id,
                           data = data_access)
  message("\nThe p-value for Kruskal-Wallis test for access events between clusters is ", 
          Krus_Wal$p.value,". (The chi-squared statistic is ", Krus_Wal$statistic[[1]], ".)")
  
  # Mann-Whitney-Wilcoxon test to test if clusters are pair-wise distinct
  counter=0
  p_value_thresh <- 0.01
  Mann_Whit_pValues <- as.data.frame(matrix(nrow = K-1, ncol = K))
  for(i in 1:(K-1))
  {
    for(j in (i+1):K)
    {
      data_subset <- subset(data_access,data_access$cluster_id==i | data_access$cluster_id==j)
      Mann_Whit <- wilcox.test(data_subset$number_accesses~data_subset$cluster_id,data=data_subset)
      message("Mann_Whit p-value between clusters ",i," and ",j,": " , Mann_Whit$p.value)
      Mann_Whit_pValues[i,j] <- Mann_Whit$p.value   #store p-values

      if(Mann_Whit$p.value > p_value_thresh)
      {
        message("\nClusters ",i," and ",j,
                " are NOT statistically significant (using p-value threshold of ", 
                p_value_thresh, ")...(p-value: ", Mann_Whit$p.value, ")...")
      }
      else
      {
        counter <- counter+1
      }
    }
  }
  #(K choose 2) pairings, if counter = (K choose 2), all clusters are pairwise significant
  if(counter==(K*(K-1)/2))
  {
    message("\nAll clusters are pairwise distinct, i.e. each pair has p-value less than 0.01...")
  }
  
  #print p-values
  message("As a table, p-values between cluster pairs are:\n")
  Mann_Whit_pValues

## Save the work environment
save.image(file = paste0("environmentVariables. ", dataSetName, ".RData"), 
           compress = T)
  
## Restore the working directory from when the script began
setwd(initialWD_save)



######## Notify user and clear the environment  #############
beepr::beep(sound = 10)   #notify user script is complete
Sys.sleep(time = 0.1)     #pause 1/10 sec
beepr::beep(sound = 10)
Sys.sleep(time = 0.1)
beepr::beep(sound = 10)


#print the amount of time the script required
cat("\n\n\nScript (3_Clustering.R) processing time details (in sec):\n")
print(proc.time() - start)

rm(list=setdiff(ls(), c('Mann_Whit_pValues', 'Krus_Wal')))   #Clear environment variables except for evaluation test values

