## ===================================================== ##
# Title:        Clustering users based on course module interaction ####
# Project:      edX data pipeline for course user clustering analytics
#               https://tzwilliams.github.io/edX-clustering/
#
# Copyright 2017 Krishna Madhavan
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#
#
# Authors:      Krishna Madhavan, Kerrie Douglas, Doipayan Roy, and Taylor Williams
# Affiliation:  Purdue University
#
# Description: Generate the clustering access graphs.  
#              *  This program uses the preprocessed_data.csv file generated by 
#               2_preprocessing.R (and the one generated by 2b_genderedSubsets.R 
#               if M/F analysis selected). 
#              *  2_preprocessing.R (and optionally 2b_genderedSubsets.R) must be 
#               run before this program is executed. 
#              *  preprocessed_data.csv (and/or preprocessed_data_females.csv 
#               and/or preprocessed_data_males.csv) is read in as the dataFrame 
#               object named 'data'
#
#
# File input stack (R: required; O: optional):
#     R:  preprocessed_data.csv         (source: pipeline script 2_Preprocessing.R)
#     O:  preprocessed_data_females.csv (source: pipeline script 2b_genderedSubsets.R)
#     O:  preprocessed_data_males.csv   (source: pipeline script 2b_genderedSubsets.R)
#     O:  *.csv (a list of users to cluster, student_id' column req'd; source: user provided)

#
# File outputs:
#       PDF figures: clustering plot, elbow plot, gap plot
#       CSV data: access data for all users, gender specified users, and cluster groups
#
# Package dependencies: readr, cluster, e1071, dplyr, [tcltk, #beepr]
#
# Changelog:
#     2017.04.13    Added gendered clickstream user choices
#                   Changed gap plots to only go up to 10 clusters (previously 
#                     was set to 20 clusters)
#     2017.05.03.   Input files read from subdirectory
#                   Created output files placed into a separate subdirectory
#     2017.05.03.   Put subdirectory and file checking code into functions
#     2017.05.08.   Code cleaning, header update
#                   Audio notification for user input and script completion 
#                     (using '#beepr' package)
#                   Plot output files set to PDF (had been EPS)
#                   Output filenames and plot subtitles are now descriptive
#                    (using the user provided description)
#     2017.05.10.   Fuzzy code updated to match updates above (which had only 
#                     been to the k-means code)
#                   Added valid user input check for clustering technique selection
#     2017.05.11.   Extracted possible functions to external files
#     2017.06.10.   Integrated Doipayan's modifications up through 2017.05.09
#                   Added timer to track script execution time
#                   Code optimizations
#     2017.07.14.   Minor code updates; added copyright information
#     2017.08.06.   Update to comments; spell check
#     2017.08.10.   Update to figure titles
#     2017.11.08.   Moved ordering clusters and plotting clusters in to external functions
#                   Saving CSV files for each cluster with userID values
#     2018.03.26.   Update to how validation p-values are printed and saved
#     2018.04.17.   Add option for user to provide a list of UIDs by which to 
#                     filter the users included in plot
#     2018.10.12.   Update to file selection (semi-automated)
#                   Add live, late, archive filtering
#                   Bug fixes

#
# Feature wish list:  (*: planned but not complete)
#                   *Comment out dependencies on "progress" package
#                   *Add in more basic (package independent) progress indicator
#                   *add option to generate all plots (All clustering techniques, all users subsets)
#                   *save the suggested cluster # (gap and elbow) to file for ref.
## ===================================================== ##



######### Clean the environment ##########
rm(list=setdiff(ls(), c("data_moduleAccess", "data_preprocessed", "gap_values", "data_access", "uniqueIDs", "elbow_plot_values")))


######### Internal functions ##########
#Function: Interactively select working directory (OS independent, but not available for RStudio Server)
InteractiveSetWD <- function() {
  cat("IMPORTANT: Select your working directory. If a folder choice window doesn't appear, look for it behind your current window.")
  setwd('~')
  #tcltk package provides an OS independent way to select a folder
  library(tcltk)
  #setting the arguments (see package documentation for details)
  .tcl.objv  <- .Tcl.args.objv('-initialdir "~" -title "Choose a working directory"')
  # open a folder selection window (defaults to 'My Documents').  Sometimes this opens in the background.
  dir <- tclvalue(tkchooseDirectory())
  setwd(dir)

  return()
}


#Function: Check to see if the current working directory contains an expected file.
# If not then prompt user to select the correct directory
WorkingDirectoryCheck <- function(expectedFile) {

  if(file.exists(file.path(getwd(), expectedFile))){
    #if file does exists in the current WD, exit the function returning TRUE
    return(TRUE)
  } else{
    #check for likely locations, set wd automatically if found and return TRUE
    if(file.exists(file.path(getwd(), "analytics", expectedFile))){
      setwd(file.path(getwd(), "analytics"))
      return(TRUE)
    } else if(file.exists(file.path(dirname(getwd()), expectedFile))){
      setwd(dirname(getwd()))   #set wd to parent directory of current wd
      return(TRUE)
    } else{
      #return FALSE if the file does not exist in the current WD (or other obvious locations)
      return(FALSE)
    }
  }
}


# end of functions
## *************************************** #####
# begin script setup


######### Check for correct working directory ##########
#check for correct expected working directory, inform user if incorrect and stop running script
current.dir <- getwd()
thisFile = "3_Clustering.R"
expectedFile = file.path(thisFile)

if(!WorkingDirectoryCheck(expectedFile)){
  message("\nThe current working directory is NOT CORRECT.
          It is currently set to '", current.dir, "'
          Please set it to the directory containing the '", thisFile,
          "' file and rerun this script.\n")

  #stop running current script
  break
}


######### Load required libraries ##########
require("dplyr")
require("tcltk")




######### External function sourcing ##########
#load external functions
source("R/file-structure-functions.R")
source("R/OrderClusters.R")
source("R/PlotClusters.R")
source("R/DisplayPercentComplete.R")

# end of script setup
## *************************************** #####



## MAIN ####
# beginning of script functionality


#start a timer to track how long the script takes to execute
start <-  proc.time() #save the time (to compute elapsed time of script)


#### save the preprocessed data from a prior run if it is in memory (to compare with current data later)
if(exists("data_preprocessed")){
  data_preprocessed_prior <- data_preprocessed
}


######### User providing dataset details #####
beepr::beep(sound = 10)   #notify user to provide input
cat("\nEnter a description of this datasest (to be included on graphs).
    (suggested format: [Data source, e.g., edX], [Course number, e.g., nano515x], [Data date, e.g., Data from 2016.11.18])")
dataSetDescription <- readline(prompt="Description: ");



######### Choose clustering technique ##########################################
#Choose clustering method (repeating to sanitize user input)
repeat{
  beepr::beep(sound = 10)   #notify user to provide input
  clusterTypeSelection <- readline(prompt="Enter '1' or {nothing} for K-means clustering, 
      '2' for c-means (fuzzy) clustering: ");
  
  if(clusterTypeSelection == 1 ||   #valid clustering method selected
     clusterTypeSelection == 2){
    #exit loop and continue script
    break
  }else if(clusterTypeSelection == ""){  #defalt to k-means
    clusterTypeSelection = 1
    #exit loop and continue script
    break
  }
  #repeat if none of the conditions were met (i.e., user input was invalid)
}


######### Calculate Live, late, archive groups #################################
#  (repeating to sanitize user input)
repeat{
  beepr::beep(sound = 10)   #notify user to provide input
  inputLLA <- readline(prompt="Enter '1' to find live, late, and archive groups,  
      '2' or {nothing} to skip  ");
  
  if(inputLLA == 1){  #find user groups
    source("R/subsetUsers_LiveLateArchive.R")
    #exit loop and continue script
    break
  }else if(inputLLA == 2 ||   #don't find user groups
           inputLLA == ""){
    #exit loop and continue script
    break
  }
  #repeat if none of the conditions were met (i.e., user input was invalid)
}


######### User selection of data set to process #####
#Choose clickstream data(sub)set (repeating to sanitize user input).  With valid input
#  save the file paths needed later for clustering
repeat{
  userIDsToInclude <- as.numeric(NULL)  #create empty list of userIDs
  
  beepr::beep(sound = 10)   #notify user to provide input
  userSubsetSelection <- readline(prompt="
Enter '1' or {nothing} for all learners,  :
      '2' or 'f' for female learners,
      '3' or 'm' for male learners,
      '4' live learners,
      '5' late learners,
      '6' archive learners,
      '7' or 'c' to provide a custom ID list");

  

  
  if(userSubsetSelection == 1 ||  #dataset: all learners 
     userSubsetSelection == ""){
    dataSetName <- "all"
    userIDsToInclude <- NULL

    break
  }
  else if(userSubsetSelection == "f" || #dataset: female learners
          userSubsetSelection == "F" ||
          userSubsetSelection == 2){
    dataSetName <- "females"
    #set subset selection variable to a known value for future use
    userSubsetSelection <- "f"
    
    filenameUserFilter <- FileExistCheck_workingDir(subDir = "2_PreprocessingOutput",
                                                    filename = "preprocessed_data_females.csv")
    
    #check to see if selected file has required column
    fileContentsCheck <- CSV_ContentCheck(CSV_path = filenameUserFilter,
                                          reqdColName = "student_id")
    
    # continue if the user provided file contains the expected column
    #exit script if file not found, otherwise continue
    ifelse(fileContentsCheck == 1, 
           yes = (userIDsToInclude <- read.csv(filenameUserFilter)$student_id),       # read list
           no = "File not found.")     #exit script if file not found, otherwise continue
    
    break
  }
  else if(userSubsetSelection == "m" ||
          userSubsetSelection == "M" ||
          userSubsetSelection == 3){  #dataset: male learners
    dataSetName <- "male"
    #set subset selection variable to a known value for future use
    userSubsetSelection <- "m"
    
    filenameUserFilter <- FileExistCheck_workingDir(subDir = "2_PreprocessingOutput",
                                                    filename = "preprocessed_data_males.csv")
    
    #check to see if selected file has required column
    fileContentsCheck <- CSV_ContentCheck(CSV_path = filenameUserFilter,
                                          reqdColName = "student_id")
    
    # continue if the user provided file contains the expected column
    #exit script if file not found, otherwise continue
    ifelse(fileContentsCheck == 1, 
           yes = (userIDsToInclude <- read.csv(filenameUserFilter)$student_id),       # read list
           no = "File not found.")     #exit script if file not found, otherwise continue
    
    
    break
  }
  else if(userSubsetSelection == 4){  #dataset: live learners
    dataSetName <- "live"
    filenameUserFilter <- FileExistCheck_workingDir(subDir = "2_PreprocessingOutput",
                                         filename = 
                                           list.files(path = "2_PreprocessingOutput", 
                                                      pattern = "^userList1"))
    
    #check to see if selected file has required column
    fileContentsCheck <- CSV_ContentCheck(CSV_path = filenameUserFilter,
                                          reqdColName = "student_id")

    # continue if the user provided file contains the expected column
    #exit script if file not found, otherwise continue
    ifelse(fileContentsCheck == TRUE, 
           yes = (userIDsToInclude <- read.csv(filenameUserFilter)$student_id),       # read list
           no = NULL)     #exit script if file not found, otherwise continue

    break
  }
  else if(userSubsetSelection == 5){  #dataset: late learners
    dataSetName <- "late"
    
    filenameUserFilter <- FileExistCheck_workingDir(subDir = "2_PreprocessingOutput",
                                                    filename = 
                                                      list.files(path = "2_PreprocessingOutput", 
                                                                 pattern = "^userList2"))
    
    #check to see if selected file has required column
    fileContentsCheck <- CSV_ContentCheck(CSV_path = filenameUserFilter,
                                          reqdColName = "student_id")
    
    # continue if the user provided file contains the expected column
    #exit script if file not found, otherwise continue
    ifelse(fileContentsCheck == TRUE, 
           yes = (userIDsToInclude <- read.csv(filenameUserFilter)$student_id),       # read list
           no = NULL)     #exit script if file not found, otherwise continue
    
    break
  }
  else if(userSubsetSelection == 6){  #dataset: archive learners
    dataSetName <- "archive"

    filenameUserFilter <- FileExistCheck_workingDir(subDir = "2_PreprocessingOutput",
                                                    filename = 
                                                      list.files(path = "2_PreprocessingOutput", 
                                                                 pattern = "^userList3"))
    
    #check to see if selected file has required column
    fileContentsCheck <- CSV_ContentCheck(CSV_path = filenameUserFilter,
                                          reqdColName = "student_id")
    
    # continue if the user provided file contains the expected column
    #exit script if file not found, otherwise continue
    ifelse(fileContentsCheck == TRUE, 
           yes = (userIDsToInclude <- read.csv(filenameUserFilter)$student_id),       # read list
           no = NULL)     #exit script if file not found, otherwise continue
    
    break
  }else if(userSubsetSelection == "c" || #dataset: custom learner set (user provided)
           userSubsetSelection == "C" ||
           userSubsetSelection == 7){
    dataSetName <- "custom learner set"
    #set subset selection variable to a known value for future use
    userSubsetSelection <- "c"

    #Locate the user list csv data file (with sanitized user input)
    filenameUserFilter <- 
      SelectFile(prompt = "*****Select a CSV file with the student_id values to cluster.*****  \n     (The IDs need to be in a column named 'student_id'.)", 
                 defaultFilename = ".csv",
                 filenamePrefix = ifelse(exists("filenamePrefix"), 
                                         yes = filenamePrefix, no = ""), 
                 fileTypeMatrix = matrix(c("CSV", ".csv"), 1, 2, byrow = TRUE),
                 dataFolderPath = DirCheckCreate("2_PreprocessingOutput"))

    #check to see if selected file has required column
    fileContentsCheck <- CSV_ContentCheck(CSV_path = filenameUserFilter,
                                          reqdColName = "student_id")
    
    # continue if the user provided file contains the expected column
    #exit script if file not found, otherwise continue
    ifelse(fileContentsCheck == TRUE, 
           yes = (userIDsToInclude <- read.csv(filenameUserFilter)$student_id),       # read list
           no = NULL)     #exit script if file not found, otherwise continue
    
    break
    }
  }#repeat if none of the conditions were met (i.e., user input was invalid)
  


## Read data and retain needed columns ####
#check for preprocessed datafile existence
preprocessedDataFilePath <- FileExistCheck_workingDir(subDir = "2_PreprocessingOutput",
                                                      filename = "preprocessed_data.csv")
#exit script if file not found, otherwise continue
ifelse(preprocessedDataFilePath == FALSE, yes = return(), no = "")

#read in data from the appropriate learner (sub)set
data_preprocessed <- readr::read_csv(preprocessedDataFilePath)


##filter "preprocessed_data.csv" to only users on the UID list
  if(length(userIDsToInclude)>0){ 
    #retain relevant users (if a custom filter list was provided)
    data_preprocessed <- data_preprocessed[data_preprocessed$student_id %in% 
                                             userIDsToInclude,]
  }


##retain relevant columns
data_preprocessed <- data_preprocessed[names(data_preprocessed) %in% 
                                         c("student_id", 
                                           "temp_student_id",
                                           "module_number",
                                           "time")]
##Ordering dataframe by temp_student_id column
data_preprocessed <- data_preprocessed[order(data_preprocessed$temp_student_id,
                                             decreasing=F),]


## Check if current data_preprocessed matches the one from a prior run (if one was in memory)
if(exists("data_preprocessed_prior")){
  priorRunMatch <- identical(data_preprocessed, data_preprocessed_prior)
}else{
  priorRunMatch <- FALSE
}

######### Save the current working directory ##########
# Set the output directory to the working directory. (wd will be restored at the end of the script)

#save current working directory
initialWD_save <- getwd()


#call function to check for the existence of the subdirectory; create it if it doesn't exist
subDirPath <- DirCheckCreate(subDir = "3_ClusteringOutput")

#set working directory for the remainder of the script
setwd(subDirPath)


## ===================================================== ##


######### Calculating number of unique module accesses for each student and saving to file########
if(priorRunMatch & 
   exists("data_access") & 
   exists("uniqueIDs")){
  cat(paste0("\nAccess events for ", length(uniqueIDs), " learner available from prior run.... Continuing\n"))
}else{
  uniqueIDs <- unique(data_preprocessed$temp_student_id)
  
  cat(paste0("\nCalculating number of access events for ", length(uniqueIDs), " learners...\n"))
  #data_access contains the number of unique module accesses for each learner
  data_access <- tibble(temp_student_id = as.numeric(),
                        number_accesses = as.numeric(),
                        student_id = as.numeric())
  
  for(i in uniqueIDs){
      temp <- subset(data_preprocessed,data_preprocessed$temp_student_id == i)
      data_access <- add_row(data_access,
                           temp_student_id = temp$temp_student_id[1],
                           number_accesses = nrow(temp),
                           student_id = temp$student_id[1])
      
      
      #| print completion progress to console   ####
      #durring first iteration, create progress status variables for main processing loop
      if(i==uniqueIDs[1])
      {
        iCount <- 0 #loop counter for completion updates
        pct <- 0  #percentage complete tracker
      }
  
      #print function
      updateVars <- DisplayPercentComplete(dataFrame = 
                                             unique(data_preprocessed$temp_student_id), 
                                           iCount, pct)
  
      #update status variables (for next iteration)
      iCount <- updateVars$iCount
      pct <- updateVars$pct
  
      #print update
      cat(updateVars$toPrint)
  }
  cat("\nDone! Saving to file...")
  
  #save the appropriate access data to a CSV file
    write.csv(x = data_access,
              file = paste0("access_data. ", dataSetName, ".csv"),
              row.names = FALSE)
}#end data_access conditional

## ===================================================== ##
#Clearing all variables except those needed later
# rm(list=setdiff(ls(), c('initialWD_save', 'userSubsetSelection', 'preprocessedDataFilePath',
#                         'data_access', 'data_preprocessed', 'clusterTypeSelection', 'clusterTypeName',
#                         'dataSetDescription', 'dataSetName', 'start')))


## **Generate gap plot from access data for K = 1 to 10 (K = number of clusters)####
## Tibshirani, R., Walther, G., & Hastie, T. (2001). Estimating the number of clusters in a data set via the gap statistic. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 63(2), 411–423. https://doi.org/10.1111/1467-9868.00293
if(priorRunMatch & exists("gap_values")){
  cat("\n\nGap plot already exists from prior run.... Continuing\n")
  
}else{
  cat("\n\nGenerating gap plot...\n")
  gap_statistic <- cluster::clusGap(as.matrix(data_access$number_accesses),
                                    K.max=10,
                                    FUN=kmeans,
                                    verbose=FALSE)
  gap_values <- (as.data.frame(gap_statistic$Tab))$gap
  #set the range of x values to include in plot
  x=1:10
  pdf.options(reset = TRUE)
  #set the PDF name
  pdf(paste0(dataSetDescription, ". ", dataSetName, ". ", "k-means_gap_plot.pdf"))
  #set plot options (including descriptive subtitle)
  plot(x = x, y = gap_values, col="black", 
       xlim = c(0,10), ylim = c(0,1),
       xlab ="Number of clusters", ylab="Gap", type="l",
       main = paste0("Gap plot for ", dataSetName,"\n",
                     dataSetDescription))
  #close the PDF creation connection
  dev.off()
  cat("\nDone!\n\n")
}# end gap plot


######### If k-means clustering chosen ######################################################

if(clusterTypeSelection==1)
{
  ##Set label
  clusterTypeName <- "k-means clustering"


  ## **Generate elbow plot from access data using K=1 to K=10 (K = number of clusters) ####
  ## Thorndike, R. L. (1953). Who belongs in the family? Psychometrika, 18(4), 267–276. https://doi.org/10.1007/BF02289263
  if(exists("elbow_plot_values")){
    cat("\n\nElbow plot already exists from prior run.... Continuing\n")
    
  }else{
    cat("\n\nGenerating elbow plot...\n")

    #elbow_plot_values is a list of betweenClusterSumofSquares/totalSumofSquares for K = 1 to 10
    elbow_plot_values <- c()
    for(k in 1:10)
    {
      K_m <- kmeans(data_access$number_accesses,
                    centers=k,
                    iter.max=50,
                    algorithm="Lloyd")
      elbow_plot_values <- c(elbow_plot_values,K_m$betweenss/K_m$totss)
      
      cat(paste0("\r Calculations ", k*10, "% commplete."))
    }
    ##Plot elbow plot
  
    #set the range of x values to include in the plot
    x=1:10
    pdf.options(reset = TRUE)
    #set the PDF name
    pdf(paste0(dataSetDescription, ". ", dataSetName, ". ", "k-means_elbow_plot.pdf"))
    #create plot option (including descriptive subtitle)
    plot(x = x, y = elbow_plot_values, col="blue", type="l",
         xlim=c(0,10), ylim=c(0,1.2), xlab="Number of clusters",
         ylab="Between cluster sum of squares / Total sum of squares",
         main=paste0("Elbow plot for ", dataSetName,"\n",
                     clusterTypeName, "\n",
                     dataSetDescription))
  
    dev.off()
    cat("\nDone!")
  }#end elbow plot
  


  ## **Make recommendations for cluster number ####
  ##Make recommendation for number of clusters based on elbow plot (once delta is less than 2%)
  for(i in 3:10)
  {
    #Calculate percentage increase in explained variance from k to k+1 clusters
    percent_inc <- (elbow_plot_values[i]-elbow_plot_values[i-1])/elbow_plot_values[i-1]
    if(percent_inc<0.02)
    {
      print(paste("Recommendation for number of clusters using elbow plot:     ", i-1),
            quote=FALSE)
      break
    }
  }

  ##Make recommendation for number of clusters based on gap statistics (first peak in plot)
  optimal_clusters <- c()
  counter <- 0
  for(i in 2:9)
  {
    if(gap_values[i-1]<gap_values[i] & gap_values[i+1]<gap_values[i])
      # {			##TODO(TW: ??): ask DR why this was removed and only one recommendation is now being provided.  If this is removed then why even solicit user input on number of clusters?  If it is removed then delete the extra variables above the "for".
      # optimal_clusters=c(optimal_clusters,i)
      # counter <- counter+1
      # }
      # if(counter==2)
      # {
      # print(paste("Recommendation for number of clusters using gap statistics:",
      # optimal_clusters[1],"or",optimal_clusters[2]))
      # break
      # }
    {
      print(paste("Recommendation for number of clusters using gap statistics: ", i),
            quote=FALSE)

      break
    }
  }

  #Clearing all variables except those needed later
  # rm(list=setdiff(ls(), c('initialWD_save', 'userSubsetSelection', 'preprocessedDataFilePath',
  #                         'data_access', 'data_preprocessed', 'clusterTypeSelection', 'clusterTypeName',
  #                         'dataSetDescription', 'dataSetName', 'start')))


  ##Get user input for number of clusters
  repeat{
    beepr::beep(sound = 10)   #notify user to provide input
    K <- readline("Enter the desired number of clusters (maximum 10): ");
    K <- as.integer(K);
    
    ifelse(!is.na(K) & (K > 0) & (K <= 10), 
           yes = break, 
           no = print("Please enter a valid number.", quote=FALSE))
  }

  #Ordering data_access in increasing order of temporary student id (integer id created for each student in preprocessing)
  data_access <- data_access[order(data_access$temp_student_id,
                                   decreasing=F),]


  #Performing K-means clustering on access data using user's choice of K
  K_m <- kmeans(data_access$number_accesses,
                centers=K,iter.max=100,algorithm="Lloyd")
  cluster_id <- K_m$cluster

  #Binding cluster_id of each student to data_access
  data_access$cluster_id <- NULL
  data_access <- cbind(data_access, cluster_id)

  #Ordering data_access in increasing order of number of unique accesses of students
  data_access <- data_access[order(data_access$number_accesses,
                                   decreasing=F),]


  # #Clearing all variables except those needed later
  # rm(list=setdiff(ls(), c('initialWD_save', 'userSubsetSelection', 'preprocessedDataFilePath',
  #                         'data_access', 'data_preprocessed', 'clusterTypeSelection', 'clusterTypeName',
  #                         'dataSetDescription', 'dataSetName', 'start')))

  ######### If c-means (fuzzy means) chosen #####################################################
} else if(clusterTypeSelection==2)
{

  ##Set label
  clusterTypeName <- "c-means (fuzzy) clustering"

  # ## **Generate gap plot from access data for K = 1 to 10 (K = number of clusters) ####
  # cat("\nGenerating gap plot...")
  # gap_statistic <- cluster::clusGap(as.matrix(data_access$number_accesses),
  #                                   K.max=10, FUN=kmeans, verbose=FALSE)   #TODO(TW:??):for DR??? should kmeans be the FUN used here?  We're in the c-means clustering section
  # gap_values <- (as.data.frame(gap_statistic$Tab))$gap
  # 
  # #Plot gap plot
  # #set the range of x values to include in the plot
  # x <- 1:10
  # #set the PDF name
  # pdf(paste0(dataSetDescription, ". ", dataSetName, ". ", "c-means_gap_plot.pdf"))
  # #set plot options (including descriptive subtitle)
  # plot(x = x,y = gap_values,col="black",xlim=c(0,10),ylim=c(0,1),
  #      xlab="Number of clusters",ylab="Gap",type="l",
  #      main = paste0("Gap plot for ", dataSetName,"\n",
  #                    clusterTypeName, "\n",
  #                    dataSetDescription))
  # #close the PDF creation connection
  # dev.off()
  # cat("\nDone!")

  ## **Make recommendation for number of clusters based on gap statistics (first peak in plot) ####
  optimal_clusters <- c()
  counter <- 0
  for(i in 2:9)
  {
    if(gap_values[i-1]<gap_values[i] & gap_values[i+1]<gap_values[i])
      # {    #TODO(TW:??): same question for DR as above in k-means section.  Why eliminate the two calculated.  Why give user the choice?
      # optimal_clusters=c(optimal_clusters,i)
      # counter <- counter+1
      # }
      # if(counter==2)
      # {
      # print(paste("Recommendation for number of clusters using gap statistics:",optimal_clusters[1],"or",optimal_clusters[2]))
      # break
      # }
    {
      print(paste("Recommendation for number of clusters using gap statistics:",i), quote=FALSE)
      break
    }
  }

  #Clearing all variables except those needed later
  # rm(list=setdiff(ls(), c('initialWD_save', 'userSubsetSelection', 'preprocessedDataFilePath',
  #                         'data_access', 'data_preprocessed', 'clusterTypeSelection', 'clusterTypeName',
  #                         'dataSetDescription', 'dataSetName', 'start')))

  ##User input for number of clusters
  beepr::beep(sound = 10)   #notify user to provide input
  K <- readline("Enter the desired number of clusters (maximum 10): ");
  K <- as.integer(K);



  #Ordering data_access in increasing order of temporary student it (integer id created for each student in preprocessing)
  data_access <- data_access[order(data_access$temp_student_id,
                                   decreasing=F),]
  #Performing C-means clustering on access data using user's choice of K clusters
  C_m <- e1071::cmeans(as.matrix(data_access$number_accesses),
                       centers=K)
  cluster_id <- C_m$cluster
  #Binding cluster_id of each student to data_access
  data_access$cluster_id <- NULL
  data_access <- cbind(data_access, cluster_id)
  #Ordering data_access in increasing order of number of unique accesses of students
  data_access <- data_access[order(data_access$number_accesses,
                                   decreasing=F),]


} else
{
  print("Invalid cluster type selected.  Please rerun script.")
}

## Ordering clusters ####
#Ordering clusters in decreasing order of accesses, heaviest user cluster comes first
#  cluster_order contains the cluster_id's ordered in increasing order of access activity
source("../R/OrderClusters.R")
cluster_order <- OrderClusters(data_access = data_access,
                               K = K)


## Plotting clusters ####
source("../R/PlotClusters.R")
PlotClusters(clusterTypeName = clusterTypeName,
             K = K,
             data_preprocessed = data_preprocessed,
             data_access = data_access,
             cluster_order = cluster_order,
             dataSetName = dataSetName,
             dataSetDescription = dataSetDescription)

## Saving UserIDs for each cluster ####
counter <- length(cluster_order)  #a counter for indicating most to least engaged clusters

for(k in cluster_order)
{
  #extract the users who are in this cluster
  curClusterUsers <- subset(data_access,data_access$cluster_id==k)  
  #only retain necessisary columns
  curClusterUsers <- select(curClusterUsers, "temp_student_id", 
                            "number_accesses", "student_id")  

  
  curClusterUsersPct <- nrow(curClusterUsers)/nrow(data_access) * 100
  curClusterUsersPct <- sprintf("%.1f", curClusterUsersPct, "%", collapse = "")
  
  if(counter == 1) {
    write.csv(x = curClusterUsers,
              paste0("access_data. ", dataSetName, ". cluster_", 
                     counter, " (of ", length(cluster_order), 
                     ") (most engaged) (", curClusterUsersPct, " pct).csv"),
              row.names = FALSE)
  }else {
    write.csv(x = curClusterUsers,
              paste0("access_data. ", dataSetName, ". cluster_", 
                     counter, " (of ", length(cluster_order), 
                     ") (", curClusterUsersPct, " pct).csv"),

              row.names = FALSE)
  }

  counter <- counter - 1
}



# Significance tests ####
  # Kruskal-Wallis test to show that clustering is statistically significant
  cat("\n\nThe results of hypothesis testing on access events between clusters: ")
  
  Krus_Wal <- kruskal.test(data_access$number_accesses ~ data_access$cluster_id,
                           data = data_access)
  message("\nThe p-value for Kruskal-Wallis test for access events between clusters is ", 
          Krus_Wal$p.value,". (The chi-squared statistic is ", Krus_Wal$statistic[[1]], ".)")
  
  # Mann-Whitney-Wilcoxon test to test if clusters are pair-wise distinct
  counter=0
  p_value_thresh <- 0.01
  Mann_Whit_pValues <- as.data.frame(matrix(nrow = K-1, ncol = K))
  for(i in 1:(K-1))
  {
    for(j in (i+1):K)
    {
      data_subset <- subset(data_access,
                            data_access$cluster_id==i | data_access$cluster_id==j)
      Mann_Whit <- wilcox.test(data_subset$number_accesses~data_subset$cluster_id,data=data_subset)
      message("Mann_Whit p-value between clusters ",i," and ",j,": " , Mann_Whit$p.value)
      Mann_Whit_pValues[i,j] <- Mann_Whit$p.value   #store p-values

      if(Mann_Whit$p.value > p_value_thresh)
      {
        message("\nClusters ",i," and ",j,
                " are NOT statistically significant (using p-value threshold of ", 
                p_value_thresh, ")...(p-value: ", Mann_Whit$p.value, ")...")
      }
      else
      {
        counter <- counter+1
      }
    }
  }
  #(K choose 2) pairings, if counter = (K choose 2), all clusters are pairwise significant
  if(counter==(K*(K-1)/2))
  {
    message("\nAll clusters are pairwise distinct, i.e. each pair has p-value less than 0.01...")
  }
  
  #print p-values
  message("As a table, p-values between cluster pairs are:\n")
  print(Mann_Whit_pValues)

## Save the work environment
save.image(file = paste0("environmentVariables. ", dataSetName, " (", length(cluster_order), ").RData"), 
           compress = T)
  
## Restore the working directory from when the script began
setwd(initialWD_save)



######## Notify user and clear the environment  #############
beepr::beep(sound = 10)   #notify user script is complete
Sys.sleep(time = 0.1)     #pause 1/10 sec
beepr::beep(sound = 10)
Sys.sleep(time = 0.1)
beepr::beep(sound = 10)


#print the amount of time the script required
cat("\n\n\nScript (3_Clustering.R) processing time details (in sec):\n")
print(proc.time() - start)

# #Clear environment variables except for evaluation test values
# rm(list=setdiff(ls(), c('Mann_Whit_pValues', 'Krus_Wal', 
#                         "data_moduleAccess", "data_courseStructure", 
#                         "dataUserProfile")))   
